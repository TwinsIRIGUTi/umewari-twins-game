<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>梅割りツインズ：もつ煮の逆襲</title>
  <style>
    html, body { margin: 0; padding: 0; background: #111; overflow: hidden; }
    canvas { display: block; background: #222; }
    #controls {
      position: fixed;
      bottom: 0;
      width: 100%;
      height: 90px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #000;
      z-index: 2;
    }
    .btn {
      width: 30%; height: 60px;
      margin: 10px;
      font-size: 18px;
      color: white;
      background: #444;
      border: 2px solid #888;
      border-radius: 10px;
    }
    #ui {
      position: fixed;
      top: 0;
      left: 0;
      color: white;
      font-family: sans-serif;
      padding: 8px;
      font-size: 16px;
      background: rgba(0,0,0,0.5);
      z-index: 3;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="controls">
  <button class="btn" id="leftBtn">← 左へ</button>
  <button class="btn" id="placeBtn">＋バリケード</button>
  <button class="btn" id="rightBtn">右へ →</button>
</div>
<div id="ui">
  <div>スコア: <span id="score">0</span></div>
  <div>時間: <span id="time">0.0</span>秒</div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 90;

const laneCount = 3;
const laneX = [...Array(laneCount)].map((_, i) => canvas.width * (i + 0.5) / laneCount);
let currentLane = 1;
let player = { x: laneX[currentLane], y: canvas.height - 60, w: 30, h: 30, vx: 0 };
let bullets = [];
let enemies = [];
let barricades = [];
let shootCounter = 0;
let gameOver = false;
let score = 0;
let startTime = Date.now();
let moveDir = 0; // -1: 左, 1: 右

const moveSpeed = 4;

const scoreEl = document.getElementById("score");
const timeEl = document.getElementById("time");

function resetGame() {
  bullets = [];
  enemies = [];
  barricades = [];
  shootCounter = 0;
  gameOver = false;
  score = 0;
  startTime = Date.now();
  player.x = laneX[1];
  currentLane = 1;
  player.vx = 0;
  scoreEl.textContent = "0";
  loop();
}

document.getElementById("leftBtn").addEventListener("touchstart", () => moveDir = -1);
document.getElementById("leftBtn").addEventListener("touchend", () => moveDir = 0);
document.getElementById("rightBtn").addEventListener("touchstart", () => moveDir = 1);
document.getElementById("rightBtn").addEventListener("touchend", () => moveDir = 0);

document.getElementById("placeBtn").addEventListener("click", () => {
  barricades.push({
    x: laneX[currentLane], y: player.y - 120, lane: currentLane, hp: 1
  });
});

function shoot() {
  bullets.push({ x: player.x, y: player.y - 10, w: 5, h: 10 });
}

function spawnEnemy() {
  const lane = Math.floor(Math.random() * laneCount);
  const hp = Math.floor(Math.random() * 3) + 1;
  enemies.push({ x: laneX[lane], y: -20, lane, hp, speed: 1 + Math.random() });
}

function update() {
  if (gameOver) return;

  // スムーズな移動
  player.x += moveDir * moveSpeed;
  // レーン判定更新
  currentLane = laneX.reduce((prev, cx, i) => 
    Math.abs(player.x - cx) < Math.abs(player.x - laneX[prev]) ? i : prev, 0);

  // 弾処理
  shootCounter++;
  if (shootCounter % 15 === 0) shoot();
  if (shootCounter % 60 === 0) spawnEnemy();

  bullets.forEach(b => b.y -= 6);
  bullets = bullets.filter(b => b.y > 0);

  enemies.forEach(e => e.y += e.speed);

  // 弾の当たり判定
  bullets.forEach(b => {
    enemies.forEach((e, j) => {
      if (e.lane === currentLane &&
          Math.abs(b.x - e.x) < 15 && Math.abs(b.y - e.y) < 20) {
        e.hp--;
        b.y = -999;
        if (e.hp <= 0) {
          enemies.splice(j, 1);
          score += 10;
          scoreEl.textContent = score;
        }
      }
    });
  });

  // バリケード処理
  enemies.forEach((e, ei) => {
    barricades.forEach((b, bi) => {
      if (e.lane === b.lane && Math.abs(e.y - b.y) < 20) {
        e.y -= e.speed;
        b.hp--;
        if (b.hp <= 0) barricades.splice(bi, 1);
      }
    });
  });

  // ゲームオーバー判定
  enemies.forEach(e => {
    if (e.y > player.y - 10 && e.lane === currentLane) {
      gameOver = true;
      const timeSurvived = ((Date.now() - startTime) / 1000).toFixed(1);
      setTimeout(() => {
        const retry = confirm(`ゲームオーバー！\nスコア: ${score}\n生存時間: ${timeSurvived}秒\n\nもう一度？`);
        if (retry) resetGame();
      }, 100);
    }
  });

  timeEl.textContent = ((Date.now() - startTime) / 1000).toFixed(1);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // プレイヤー
  ctx.fillStyle = "cyan";
  ctx.fillRect(player.x - player.w/2, player.y - player.h/2, player.w, player.h);

  // 弾
  ctx.fillStyle = "white";
  bullets.forEach(b => ctx.fillRect(b.x - 2, b.y - 5, b.w, b.h));

  // 敵
  enemies.forEach(e => {
    ctx.fillStyle = ["#7f0", "#fc0", "#f00"][Math.min(e.hp-1,2)];
    ctx.beginPath();
    ctx.arc(e.x, e.y, 15, 0, Math.PI * 2);
    ctx.fill();
  });

  // バリケード
  ctx.fillStyle = "orange";
  barricades.forEach(b => ctx.fillRect(b.x - 10, b.y - 10, 20, 20));
}

function loop() {
  update();
  draw();
  if (!gameOver) requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
